#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f download.sh 
#endif

static  char data [] = 
#define      lsto_z	1
#define      lsto	((&data[0]))
	"\025"
#define      tst1_z	22
#define      tst1	((&data[4]))
	"\304\007\006\056\112\011\143\105\370\220\031\353\065\252\341\235"
	"\324\220\100\375\214\260\230\257\047\057\171\336"
#define      rlax_z	1
#define      rlax	((&data[29]))
	"\354"
#define      msg1_z	65
#define      msg1	((&data[41]))
	"\020\365\356\200\003\236\104\350\225\106\045\174\215\323\067\121"
	"\151\265\172\362\162\340\171\063\062\126\024\010\071\146\250\202"
	"\172\031\114\052\212\074\206\335\106\121\257\112\271\247\141\135"
	"\276\063\130\351\253\004\231\266\166\043\306\233\144\101\173\262"
	"\320\230\327\261\006\057\342\216\122\373\266\277\315\100\226\310"
	"\105\375\152\310"
#define      opts_z	1
#define      opts	((&data[114]))
	"\071"
#define      chk2_z	19
#define      chk2	((&data[119]))
	"\245\016\373\270\302\020\007\004\323\363\060\102\173\354\364\367"
	"\013\233\101\173\250\051\207\303\173\310"
#define      text_z	2314
#define      text	((&data[381]))
	"\274\010\215\244\236\323\311\154\024\140\064\132\135\236\043\037"
	"\021\363\020\374\241\266\013\234\156\317\030\066\210\202\177\104"
	"\212\014\351\051\340\263\225\365\023\311\120\160\150\163\220\171"
	"\147\240\166\010\127\202\244\305\121\274\374\331\076\173\036\311"
	"\210\010\363\151\273\210\137\317\121\257\100\272\043\320\063\212"
	"\161\252\222\310\054\066\215\175\363\211\126\062\005\165\373\215"
	"\175\356\367\070\167\126\010\311\005\110\203\050\030\267\262\211"
	"\141\105\121\216\173\337\013\157\151\142\241\156\327\235\374\124"
	"\214\363\215\003\111\225\315\116\336\120\167\366\010\052\177\152"
	"\157\321\370\353\260\004\132\031\146\374\210\076\231\204\223\045"
	"\167\041\051\301\267\366\020\225\106\207\213\117\262\013\271\042"
	"\335\262\015\216\267\150\250\035\144\060\134\375\264\357\043\054"
	"\021\114\356\310\102\376\135\211\206\351\330\070\365\222\133\322"
	"\105\150\140\374\321\010\032\066\071\166\064\355\146\127\032\167"
	"\243\010\100\346\007\236\157\215\207\110\306\174\333\041\117\040"
	"\012\217\325\266\204\200\341\231\101\271\365\101\274\037\154\113"
	"\043\235\017\016\026\335\047\334\011\140\161\104\104\137\205\104"
	"\326\136\205\246\104\147\266\076\032\044\026\220\007\046\025\375"
	"\232\163\111\344\241\344\005\175\217\214\120\174\261\170\320\134"
	"\307\131\351\163\067\064\046\103\040\142\102\314\365\175\313\266"
	"\135\257\103\013\106\333\263\066\373\160\064\110\362\262\042\112"
	"\355\100\237\310\345\160\243\051\233\047\377\225\103\225\324\104"
	"\131\277\367\337\114\043\166\326\035\245\175\251\271\112\210\175"
	"\002\007\274\015\017\053\057\362\345\343\154\073\162\163\204\111"
	"\342\006\304\057\010\311\143\305\052\020\142\056\301\103\120\262"
	"\373\216\351\336\016\315\370\271\346\103\307\050\345\274\276\346"
	"\100\056\254\101\363\236\300\222\322\153\026\234\235\115\306\151"
	"\272\273\200\216\134\066\333\366\361\247\012\032\262\072\307\154"
	"\130\005\113\252\353\214\025\064\164\303\023\216\215\144\361\100"
	"\110\202\020\237\157\333\172\100\120\357\212\147\005\265\056\301"
	"\045\341\277\002\255\042\067\255\113\251\334\061\050\007\314\325"
	"\050\064\333\117\370\047\366\001\010\110\336\014\307\171\164\253"
	"\331\112\020\320\032\366\074\235\322\167\310\034\223\123\171\245"
	"\007\231\362\221\306\232\326\061\112\035\135\323\173\341\241\326"
	"\043\255\231\006\205\017\222\067\045\171\023\321\335\347\035\061"
	"\077\163\111\023\006\000\120\132\104\231\172\132\353\351\302\262"
	"\076\342\256\344\163\232\343\367\102\167\207\025\037\134\101\103"
	"\343\121\174\104\035\344\147\245\132\376\264\364\033\021\006\247"
	"\140\214\374\276\123\000\276\203\072\320\242\077\124\074\034\334"
	"\063\257\235\004\070\210\255\045\235\060\354\334\122\172\064\236"
	"\162\056\371\250\114\337\213\362\125\132\341\246\033\163\233\317"
	"\053\336\361\262\216\140\122\066\046\011\315\074\141\331\221\256"
	"\344\117\002\134\066\010\343\016\246\135\052\013\161\217\216\167"
	"\365\343\314\037\155\254\347\335\156\310\012\111\247\274\170\145"
	"\246\240\345\144\064\346\210\141\356\155\200\067\223\021\306\063"
	"\143\225\327\221\343\304\253\177\137\326\214\357\331\223\167\023"
	"\053\252\025\104\336\167\200\140\325\165\374\110\055\134\010\103"
	"\345\352\315\071\043\035\154\234\221\305\333\277\057\053\056\115"
	"\236\050\247\353\367\245\331\155\024\101\124\123\234\224\220\162"
	"\251\231\226\203\253\321\306\303\024\202\023\277\274\177\362\364"
	"\024\311\232\311\346\277\002\040\116\052\012\023\007\235\345\332"
	"\060\236\352\045\320\237\151\343\057\106\232\063\376\224\205\325"
	"\246\160\263\265\272\023\207\310\221\107\160\135\026\120\210\357"
	"\210\123\052\154\271\206\067\156\022\046\225\202\245\074\004\321"
	"\111\233\116\136\162\223\300\242\102\365\116\110\147\021\257\245"
	"\143\241\114\174\025\022\031\166\157\117\312\363\214\104\227\367"
	"\055\262\061\070\064\211\334\315\273\252\352\172\157\122\223\121"
	"\025\321\116\263\127\137\225\073\367\125\260\032\124\100\322\016"
	"\272\244\025\242\332\156\277\312\152\106\032\315\007\070\120\000"
	"\333\006\357\003\371\135\034\131\344\123\333\230\325\033\166\345"
	"\277\243\237\035\212\010\004\330\360\373\317\342\007\277\051\041"
	"\241\157\044\346\342\300\374\007\375\342\265\334\117\136\160\271"
	"\362\173\014\264\022\205\120\170\257\356\107\010\351\333\373\032"
	"\044\273\351\325\116\254\130\123\066\070\147\011\224\273\237\370"
	"\124\125\234\372\207\326\220\200\060\072\110\340\044\036\355\201"
	"\371\311\103\065\200\264\266\222\375\152\331\301\103\274\035\132"
	"\167\262\166\255\302\170\363\354\266\376\002\133\326\245\010\337"
	"\324\074\242\311\266\000\347\354\015\354\147\033\074\043\136\137"
	"\233\316\131\245\005\125\314\111\133\274\013\067\220\150\243\213"
	"\134\260\066\172\164\313\066\023\030\015\353\072\151\236\000\165"
	"\222\245\354\111\106\177\010\104\254\035\215\052\273\160\115\076"
	"\045\263\240\165\040\336\306\117\136\366\256\057\302\050\354\255"
	"\143\152\304\001\037\324\034\001\266\351\312\222\200\314\271\014"
	"\126\157\342\325\175\111\121\060\261\100\146\064\253\020\036\255"
	"\074\102\174\276\106\276\330\246\345\357\340\021\174\316\242\271"
	"\267\140\101\036\371\062\016\170\321\276\036\345\322\163\330\116"
	"\276\265\341\127\231\032\175\054\075\224\300\070\244\141\353\352"
	"\364\351\062\202\332\306\112\005\224\347\240\061\064\033\175\264"
	"\156\200\200\230\215\171\341\166\067\262\044\177\375\104\355\260"
	"\100\003\050\351\042\042\375\331\101\114\340\064\300\003\211\326"
	"\331\314\251\176\057\161\131\140\375\042\331\047\171\004\001\277"
	"\332\104\057\215\241\075\333\036\246\010\215\347\237\360\314\313"
	"\130\267\212\367\241\151\207\260\122\332\345\247\031\152\276\107"
	"\361\014\305\326\241\271\376\256\144\043\306\056\026\362\035\053"
	"\023\056\362\076\061\334\363\247\034\100\247\045\361\275\100\060"
	"\307\157\007\172\342\075\126\146\242\143\334\233\214\106\052\265"
	"\147\026\031\004\253\133\370\263\077\000\130\124\201\174\156\005"
	"\046\114\256\003\327\001\111\246\330\247\117\013\237\224\127\236"
	"\160\114\165\271\040\122\120\126\056\077\157\234\365\372\021\056"
	"\222\111\243\271\227\347\036\171\212\374\373\262\220\136\022\034"
	"\042\134\136\015\316\155\137\344\365\335\003\102\370\257\151\373"
	"\327\254\272\235\117\266\166\233\220\101\215\316\111\111\332\054"
	"\262\123\024\131\054\314\315\253\112\274\226\144\102\254\057\210"
	"\130\172\245\325\044\254\140\124\343\056\130\272\141\271\211\102"
	"\230\031\152\252\222\347\201\131\334\263\146\241\112\312\022\333"
	"\014\134\353\250\365\371\130\377\031\057\254\030\154\115\241\203"
	"\011\214\016\246\320\170\370\100\007\244\247\245\227\332\245\374"
	"\344\357\015\261\362\216\230\350\272\271\176\263\225\311\013\114"
	"\125\165\123\062\061\262\075\315\025\227\011\006\202\237\337\102"
	"\152\240\315\024\175\173\112\343\217\150\372\062\004\137\317\264"
	"\301\366\057\234\002\354\067\032\050\165\340\237\254\050\052\210"
	"\020\257\353\217\336\012\316\012\377\251\155\143\156\047\013\051"
	"\241\017\143\003\075\000\341\257\073\120\354\324\150\010\055\054"
	"\205\132\236\155\201\134\315\344\101\165\176\114\334\036\302\243"
	"\262\325\206\225\070\271\277\241\151\356\360\230\170\364\305\003"
	"\362\102\375\221\170\231\005\340\371\144\362\270\220\351\250\111"
	"\214\253\051\224\004\332\156\067\140\254\027\263\163\334\061\125"
	"\006\203\311\130\141\000\143\332\333\154\100\257\362\034\131\305"
	"\010\043\173\047\276\073\120\057\071\222\134\013\070\171\376\204"
	"\066\346\355\325\366\114\324\243\330\361\364\160\036\367\200\034"
	"\253\300\131\303\037\067\333\364\377\343\364\261\162\344\216\113"
	"\254\202\371\224\254\230\233\071\174\343\054\365\071\014\060\051"
	"\317\046\236\271\332\032\377\323\117\274\270\335\304\002\330\146"
	"\166\325\307\324\255\144\061\325\104\202\360\330\041\370\175\325"
	"\200\101\145\360\263\170\062\346\177\133\113\234\304\150\043\317"
	"\351\275\007\251\300\341\000\075\335\066\315\264\257\313\230\020"
	"\361\070\062\275\215\275\054\117\363\210\151\171\265\373\146\323"
	"\255\124\355\225\010\220\152\054\237\027\026\033\326\153\123\250"
	"\130\160\063\146\031\241\122\270\153\133\006\036\014\012\267\047"
	"\227\043\370\335\241\136\337\301\174\223\374\321\352\025\051\047"
	"\315\143\237\203\011\043\033\107\143\215\234\335\030\205\137\376"
	"\021\275\346\152\362\006\112\146\153\172\250\133\336\017\065\263"
	"\204\046\305\331\041\273\150\200\377\270\061\312\303\031\323\057"
	"\303\046\314\313\164\103\364\075\357\042\361\166\341\067\342\002"
	"\224\337\073\066\002\257\076\025\056\216\067\126\366\052\232\071"
	"\254\266\200\312\361\033\322\377\206\015\025\366\121\363\351\111"
	"\170\364\134\264\013\334\051\147\064\131\174\005\106\012\364\024"
	"\306\201\126\055\140\106\243\172\174\255\354\174\320\104\371\235"
	"\027\134\127\016\211\114\012\011\003\237\153\076\042\103\156\345"
	"\245\252\144\052\332\171\307\251\156\250\045\142\046\170\173\320"
	"\166\047\352\131\014\173\240\374\140\374\032\045\327\351\227\324"
	"\244\177\010\335\123\002\174\025\130\346\067\226\302\043\066\001"
	"\121\133\357\240\365\362\320\162\313\170\363\071\200\040\074\132"
	"\171\111\030\037\320\132\333\012\337\137\076\302\216\356\212\173"
	"\311\200\032\137\125\307\036\263\040\160\273\342\110\141\223\353"
	"\166\042\370\351\001\264\226\124\135\310\355\247\024\063\106\137"
	"\323\365\226\333\006\307\070\023\164\171\311\116\035\317\145\267"
	"\271\210\057\351\165\011\246\071\320\200\361\367\074\302\056\054"
	"\303\176\230\346\344\052\061\246\361\124\377\352\312\075\046\304"
	"\076\130\173\055\143\353\320\210\310\323\315\356\014\113\220\033"
	"\350\250\103\317\212\243\305\027\101\171\115\206\355\166\061\113"
	"\373\123\010\170\015\166\130\315\126\112\326\301\311\150\333\347"
	"\156\163\124\245\111\137\273\010\235\306\362\025\064\001\370\150"
	"\133\132\105\065\237\307\013\214\267\212\142\236\072\011\216\057"
	"\342\137\307\150\233\214\327\377\053\260\206\226\373\134\107\122"
	"\122\236\026\330\031\067\034\051\162\101\233\352\266\214\243\222"
	"\064\043\064\000\060\360\155\043\141\103\201\030\044\345\047\303"
	"\304\246\035\060\216\306\040\047\004\327\343\302\361\033\022\005"
	"\154\131\035\321\172\357\204\113\321\243\177\223\122\044\133\117"
	"\211\043\374\145\210\070\343\173\305\107\040\160\264\106\215\377"
	"\127\065\150\033\303\042\013\201\370\301\331\112\013\255\111\233"
	"\276\327\165\116\117\166\034\005\236\057\145\273\202\030\300\205"
	"\322\004\254\311\056\160\332\060\376\207\163\376\075\010\066\043"
	"\342\250\033\224\153\013\163\032\113\077\017\116\270\357\102\012"
	"\163\247\046\042\113\141\036\015\000\272\265\177\143\134\271\356"
	"\334\075\307\211\356\131\244\252\202\115\106\313\346\142\320\275"
	"\070\265\332\131\133\220\004\337\046\337\072\256\115\004\320\330"
	"\154\013\325\246\033\171\351\010\364\277\101\126\314\214\073\037"
	"\233\237\164\344\245\057\170\005\135\133\202\147\344\302\004\253"
	"\377\046\125\074\263\326\140\170\223\212\212\257\034\134\270\067"
	"\222\361\255\306\337\024\036\372\214\302\003\315\250\012\153\030"
	"\230\362\140\137\157\073\201\276\134\014\156\171\150\047\260\373"
	"\031\136\301\370\163\340\363\000\242\366\315\112\001\070\143\231"
	"\053\303\371\232\377\172\131\134\206\310\325\357\360\206\352\011"
	"\344\254\002\130\214\365\130\057\353\045\171\355\135\335\206\210"
	"\240\200\043\240\372\175\375\201\106\323\160\066\131\133\077\076"
	"\010\101\226\225\066\356\304\042\023\076\017\161\033\226\372\274"
	"\026\036\134\021\234\132\222\342\055\003\030\206\137\130\305\147"
	"\231\133\374\320\112\300\363\136\376\003\317\031\232\312\325\261"
	"\351\062\302\205\215\125\147\272\130\200\101\270\330\006\037"
#define      chk1_z	22
#define      chk1	((&data[2862]))
	"\103\254\061\121\207\220\154\157\065\001\325\141\377\332\154\140"
	"\234\104\230\041\026\256\135\101"
#define      tst2_z	19
#define      tst2	((&data[2885]))
	"\333\174\320\371\375\367\234\220\164\240\163\127\220\332\075\242"
	"\155\332\006\112"
#define      shll_z	10
#define      shll	((&data[2906]))
	"\325\245\252\256\332\046\333\263\000\343\255\213\312\206"
#define      msg2_z	19
#define      msg2	((&data[2922]))
	"\023\212\236\173\043\310\272\334\144\273\104\311\244\025\135\036"
	"\013\012\332\374\051\241\352\105"
#define      pswd_z	256
#define      pswd	((&data[3005]))
	"\257\323\215\317\106\357\353\212\233\307\301\246\243\374\201\230"
	"\321\046\142\130\264\140\241\310\352\100\103\057\067\076\266\347"
	"\022\103\266\131\062\241\343\316\151\245\165\014\241\366\245\163"
	"\035\007\313\322\150\155\233\122\255\336\202\345\035\071\314\061"
	"\276\266\010\232\373\100\224\346\261\303\045\276\127\100\067\106"
	"\122\130\314\231\330\202\234\016\324\142\231\227\244\063\310\143"
	"\352\321\375\345\022\221\314\303\124\362\201\254\062\271\362\204"
	"\022\276\035\353\101\272\371\026\035\223\255\301\306\166\045\261"
	"\107\042\226\132\264\143\035\011\125\237\265\207\131\250\014\153"
	"\147\051\126\250\343\120\276\000\343\154\302\252\342\347\133\052"
	"\012\362\204\277\126\242\310\253\102\176\063\233\046\077\006\215"
	"\150\135\066\114\256\365\115\221\141\020\074\104\367\230\157\002"
	"\213\364\301\341\226\212\214\330\011\277\163\057\376\172\275\147"
	"\330\364\264\206\351\002\030\112\022\124\217\011\354\376\014\170"
	"\363\316\131\211\130\346\142\141\246\326\221\244\121\117\014\051"
	"\103\301\260\054\303\310\167\325\034\006\337\011\005\353\201\370"
	"\271\333\202\022\301\345\163\147\274\005\014\015\124\031\067\227"
	"\332\347\303\236\257\073\163\314\101\122\326\107\076\130\100\370"
	"\064\302\012\365\250\176\135\144\203\152\162\327\204\251\157\137"
	"\221\062\375\101\156\160\015\257\303\344\367\002\074\067\372\060"
	"\174\203\211\257\045\155\176\217\022\363\234\264\352\101\047\010"
	"\111\363\332\261\141\165\004\016\124\207\364\161\300\301\241\074"
	"\104"
#define      date_z	1
#define      date	((&data[3295]))
	"\352"
#define      inlo_z	3
#define      inlo	((&data[3296]))
	"\150\265\034"
#define      xecc_z	15
#define      xecc	((&data[3300]))
	"\137\116\130\223\252\315\026\062\273\102\137\267\127\103\277\361"
	"\110\326"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
